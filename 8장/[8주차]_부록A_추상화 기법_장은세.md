**추상화 기법**

> 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델로 만드는데 사용

<img src="https://github.com/EunseJang/the-essence-of-object-orientation-readers/assets/113760409/16dde891-4ecc-4deb-ae35-103bfae5d772" width="80%">

```
분류 ↔ 인스턴스화
일반화 ↔ 특수화
집합 ↔ 분해
```

## 분류와 인스턴스화
- 개념: 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어
- 객체: 수많은 개별적인 현상들 (= **타입의 인스턴스**)
- 타입: 개념의 동의어. 속성과 행위가 유사한 객체에 공토적으로 적용되는 관념이나 아이디어

**분류**
- 객체들의 특정 집합에 공통의 개념을 적용하는 것
- 객체에 개념을 적용하는 과정
- 객체를 타입과 연관시키는 것
- 타입의 정의에 부합할 경우, 해당 타입으로 분류되며 타입의 인스턴스가 됨

**타입**
> 객체를 타입에 따라 분류하기 위해서는 객체가 타입에 속하는지 여부를 확인할 수 있어야 함
- 심볼: 타입을 가리키는 간략한 이름이나 명칭
- 내연: 타입의 완전한 정의. 내연의 의미를 이용해 객체가 타입에 속하는지 확인
- 외연: 타입에 속하는 모든 객체들의 집합
<img src="https://github.com/EunseJang/the-essence-of-object-orientation-readers/assets/113760409/a29557e5-9fae-4b91-b7e1-c930f85e0ac1" width="50%">


*ex) 자동차라는 심볼은 내연과 외연에 심볼을 붙임으로써 타입을 쉽게 참조하고 커뮤니케이션 가능*

</br>

### 외연과 집합
```
단일 분류: 한 시점에 하나의 타입에만 속하는 경우
다중 분류: 한 객체가 한 시점에 여러 타입에 속하는 경우
```
```
다중 상속: 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용, 타입 정의는 생략 불가
다중 분류: 특정한 타입을 정의 없이, 하나의 객체가 서로 다른 타입의 인스턴스가 되도록 허용
```
```
동적 분류: 객체가 한 집합에서 다른 집합의 원소로 타입을 변경 가능한 경우
정적 분류: 객체가 자신의 타입을 변경할 수 없는 경우
```
- 객체들은 동시에 서로 다른 집합에 포함 가능
- 다중 분류와 동적 분류를 함께 적용하는 것이 실세계의 복잡성을 모델링하는데 유용
- 그러나, 객체지향 프로그래밍 언어의 제약으로 이는 구현이 쉽지 않음
> 따라서 다중 분류와 동적 분류 관점에서 도메인 모델의 초안을 만든 후, </br>
> 실제 구현에 적합하도록 **단일 분류**와 **정적 분류** 방식으로 객체드의 범주를 재조정하는 것이 현실적인 방법

</br>

**클래스**
- 타입을 구현하는 가장 보편적인 방법
- 코드 재사용 용도로도 사용
>**클래스 기반의 객체지향 언어**
>- 객체가 공유하는 본질적인 속성을 정의
>- 동일한 범주에 속하는 객체는 모두 동일한 속성을 가져야 함

</br>

### 일반화와 특수화
**린네의 분류 체계**
- 범주 간의 계층적 구조를 가짐
- 상위 계층: 계층의 하위에 위치한 범주의 **일반화**
- 하위 계층: 세부적인 범주, 상위에 위치한 범주의 **특수화**

**슈퍼타입**
- 다른 타입보다 일반적인 타입
- 서브타입의 일반화

**서브타입**
- 다른 타입보다 좀 더 특수한 타입 (**슈퍼타입의 특수화**)
- 슈퍼타입이 가진 본질적인 속성 + 자신만의 추가적인 속성
- 특정 속성을 가지고 있음을 알게 되면, 하위 범주에 속하는 다른 객체도 그 속성을 가지고 있을 것
```
내연의 관점: 슈퍼타입 정의가 서브타입 정의보다 더 일반적, 일반화와 특수화는 범주간 논리적 추론 가능
외연의 관점: 서브타입은 슈퍼타입의 부분집합으로 표현 가능
```

### 상속
> 코드의 중복을 방지하고, 공통 코드를 재사용하기 위한 언어적 메커니즘 제공

**서브 타이핑** 
- 인터페이스 상속
- 서브 클래스가 슈퍼클래스를 대체할 수 있는 경우
- 설계의 유연성을 목표로 함
  
**서브 클래싱**
- 구현 상속
- 서브클래스가 슈퍼클래스를 대체할 수 없는 경우
- 코드의 중복 제거와 재사용이 목적임    

**일반화의 원칙**
- 서브타입이 되기 위해선 슈퍼타입에 순응해야 함

**구조적인 순응**
- 타입의 내연과 관련된 **100% 규칙**을 의미
- 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 함
- 슈퍼타입을 대체하더라도 구조에 관한 동일한 기대 집합을 만족시킴

**행위적인 순응**
- 타입의 행위에 관한 것, **리스코프 치환 원칙**이라고도 함
- 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 함

**위임**
- 여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법
- 클래스 기반: 부모클레스와 자식클래스 간의 관계로 상속 이루어짐
- 프로토타입 기반: 부모객체와 자식객체 간의 관계로 상속이 이루어짐

```
요약: 일반화를 위한 서브타이핑은 특정 기대 집합에 대한 서브타입과 슈퍼타입 간의 구조적, 또는 행위적 순응 관계를 의미하며, 대체 가능성을 내포한다.
```

</br>

## 집합과 분해
- 집합 = 추상화 메커니즘 + 캡술화 매커니즘
- 내부의 구성을 변경하더라도 외부에 영향 X
